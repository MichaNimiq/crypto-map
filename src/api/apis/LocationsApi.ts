/* tslint:disable */
/* eslint-disable */
/**
 * Crypto Map API documentation
 * The Shop Directory API is serves a list of shops that accept crypto as a payment method.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CategoriesIssuesInner,
  CryptoLocation,
  CurrenciesInner,
  LocationCandidateBody,
  LocationCandidateResponse,
  LocationIssueBody,
  LocationIssueResponse,
} from '../models';
import {
    CategoriesIssuesInnerFromJSON,
    CategoriesIssuesInnerToJSON,
    CryptoLocationFromJSON,
    CryptoLocationToJSON,
    CurrenciesInnerFromJSON,
    CurrenciesInnerToJSON,
    LocationCandidateBodyFromJSON,
    LocationCandidateBodyToJSON,
    LocationCandidateResponseFromJSON,
    LocationCandidateResponseToJSON,
    LocationIssueBodyFromJSON,
    LocationIssueBodyToJSON,
    LocationIssueResponseFromJSON,
    LocationIssueResponseToJSON,
} from '../models';

export interface GetLocationByIdRequest {
    locationId: string;
}

export interface PostCandidateRequest {
    locationCandidateBody?: LocationCandidateBody;
}

export interface PostLocationIssueRequest {
    locationIssueBody?: LocationIssueBody;
}

export interface SearchLocationsRequest {
    filterCity?: string;
    filterCountry?: string;
    filterCurrency?: Array<string>;
    filterDescription?: string;
    filterEmail?: string;
    filterLabel?: string;
    filterAddressLine1?: string;
    filterAddressLine2?: string;
    filterAddressLine3?: string;
    filterNumber?: number;
    filterWebsite?: string;
    filterZip?: string;
    filterBoundingBox?: string;
    filterLimit?: number;
    filterDigitalGoods?: boolean;
}

/**
 * 
 */
export class LocationsApi extends runtime.BaseAPI {

    /**
     * Currencies
     */
    async getCurrenciesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CurrenciesInner>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/currencies`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CurrenciesInnerFromJSON));
    }

    /**
     * Currencies
     */
    async getCurrencies(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CurrenciesInner>> {
        const response = await this.getCurrenciesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get issue categories with its label
     */
    async getIssueCategoriesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CategoriesIssuesInner>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/issue_categories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CategoriesIssuesInnerFromJSON));
    }

    /**
     * Get issue categories with its label
     */
    async getIssueCategories(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CategoriesIssuesInner>> {
        const response = await this.getIssueCategoriesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get location by id
     */
    async getLocationByIdRaw(requestParameters: GetLocationByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CryptoLocation>> {
        if (requestParameters.locationId === null || requestParameters.locationId === undefined) {
            throw new runtime.RequiredError('locationId','Required parameter requestParameters.locationId was null or undefined when calling getLocationById.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/location/{locationId}`.replace(`{${"locationId"}}`, encodeURIComponent(String(requestParameters.locationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CryptoLocationFromJSON(jsonValue));
    }

    /**
     * Get location by id
     */
    async getLocationById(requestParameters: GetLocationByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CryptoLocation> {
        const response = await this.getLocationByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new candidate for a location
     */
    async postCandidateRaw(requestParameters: PostCandidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LocationCandidateResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/location`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocationCandidateBodyToJSON(requestParameters.locationCandidateBody),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LocationCandidateResponseFromJSON(jsonValue));
    }

    /**
     * Create a new candidate for a location
     */
    async postCandidate(requestParameters: PostCandidateRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LocationCandidateResponse> {
        const response = await this.postCandidateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new issue for a location
     */
    async postLocationIssueRaw(requestParameters: PostLocationIssueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LocationIssueResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/issue`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LocationIssueBodyToJSON(requestParameters.locationIssueBody),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LocationIssueResponseFromJSON(jsonValue));
    }

    /**
     * Create a new issue for a location
     */
    async postLocationIssue(requestParameters: PostLocationIssueRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LocationIssueResponse> {
        const response = await this.postLocationIssueRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * search
     */
    async searchLocationsRaw(requestParameters: SearchLocationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CryptoLocation>>> {
        const queryParameters: any = {};

        if (requestParameters.filterCity !== undefined) {
            queryParameters['filter[city]'] = requestParameters.filterCity;
        }

        if (requestParameters.filterCountry !== undefined) {
            queryParameters['filter[country]'] = requestParameters.filterCountry;
        }

        if (requestParameters.filterCurrency) {
            queryParameters['filter[currency]'] = requestParameters.filterCurrency;
        }

        if (requestParameters.filterDescription !== undefined) {
            queryParameters['filter[description]'] = requestParameters.filterDescription;
        }

        if (requestParameters.filterEmail !== undefined) {
            queryParameters['filter[email]'] = requestParameters.filterEmail;
        }

        if (requestParameters.filterLabel !== undefined) {
            queryParameters['filter[label]'] = requestParameters.filterLabel;
        }

        if (requestParameters.filterAddressLine1 !== undefined) {
            queryParameters['filter[address_line_1]'] = requestParameters.filterAddressLine1;
        }

        if (requestParameters.filterAddressLine2 !== undefined) {
            queryParameters['filter[address_line_2]'] = requestParameters.filterAddressLine2;
        }

        if (requestParameters.filterAddressLine3 !== undefined) {
            queryParameters['filter[address_line_3]'] = requestParameters.filterAddressLine3;
        }

        if (requestParameters.filterNumber !== undefined) {
            queryParameters['filter[number]'] = requestParameters.filterNumber;
        }

        if (requestParameters.filterWebsite !== undefined) {
            queryParameters['filter[website]'] = requestParameters.filterWebsite;
        }

        if (requestParameters.filterZip !== undefined) {
            queryParameters['filter[zip]'] = requestParameters.filterZip;
        }

        if (requestParameters.filterBoundingBox !== undefined) {
            queryParameters['filter[bounding_box]'] = requestParameters.filterBoundingBox;
        }

        if (requestParameters.filterLimit !== undefined) {
            queryParameters['filter[limit]'] = requestParameters.filterLimit;
        }

        if (requestParameters.filterDigitalGoods !== undefined) {
            queryParameters['filter[digital_goods]'] = requestParameters.filterDigitalGoods;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CryptoLocationFromJSON));
    }

    /**
     * search
     */
    async searchLocations(requestParameters: SearchLocationsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CryptoLocation>> {
        const response = await this.searchLocationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
